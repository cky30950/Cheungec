<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­é†«è¨ºç—‡è¼”åŠ©å·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .search-highlight {
            background: linear-gradient(120deg, #fbbf24 0%, #f59e0b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-lg border-b border-gray-200">
        <div class="max-w-7xl mx-auto px-6 py-4">
            <div class="flex items-center justify-between">
                <div class="flex items-center space-x-3">
                    <div class="w-10 h-10 bg-gradient-to-r from-emerald-500 to-teal-600 rounded-lg flex items-center justify-center">
                        <span class="text-white font-bold text-lg">ä¸­</span>
                    </div>
                    <h1 class="text-2xl font-bold text-gray-800">ä¸­é†«è¨ºç—‡è¼”åŠ©å·¥å…·</h1>
                </div>
                <div class="flex space-x-3">
                    <button id="exportBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center space-x-2">
                        <span>ğŸ’¾</span>
                        <span>å‚™ä»½è³‡æ–™</span>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <div class="max-w-7xl mx-auto px-6 py-8">
        <!-- Search Section -->
        <div class="bg-white rounded-2xl shadow-xl p-8 mb-8">
            <div class="text-center mb-6">
                <h2 class="text-3xl font-bold text-gray-800 mb-2">æ™ºèƒ½æœå°‹ç³»çµ±</h2>
                <p class="text-gray-600">æœå°‹ç—‡ç‹€æ‰¾ä¸­è—¥ï¼Œæˆ–æœå°‹ä¸­è—¥æ‰¾ç—‡ç‹€</p>
            </div>
            
            <div class="max-w-2xl mx-auto">
                <div class="relative">
                    <input 
                        type="text" 
                        id="searchInput" 
                        placeholder="è¼¸å…¥ç—‡ç‹€æˆ–ä¸­è—¥åç¨±..." 
                        class="w-full px-6 py-4 text-lg border-2 border-gray-300 rounded-xl focus:border-blue-500 focus:outline-none transition-colors"
                        autocomplete="off"
                    >
                    <button id="searchBtn" class="absolute right-2 top-2 px-6 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors">
                        ğŸ” æœå°‹
                    </button>
                    <div id="searchSuggestions" class="absolute top-full left-0 right-0 bg-white border border-gray-200 rounded-lg shadow-lg mt-1 hidden z-10 max-h-64 overflow-y-auto"></div>
                </div>
                
                <!-- Search Tips -->
                <div class="mt-4 text-center">
                    <p class="text-sm text-gray-500 mb-2">ğŸ’¡ æœå°‹æç¤ºï¼š</p>
                    <div class="flex flex-wrap justify-center gap-2">
                        <span class="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-xs">æ”¯æ´æ¨¡ç³Šæœå°‹</span>
                        <span class="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-xs">è‡ªå‹•éŒ¯å­—ä¿®æ­£</span>
                        <span class="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-xs">é—œè¯æœå°‹</span>
                        <span class="px-3 py-1 bg-gray-100 text-gray-700 rounded-full text-xs">èªéŸ³ç›¸ä¼¼</span>
                    </div>
                </div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="bg-white rounded-2xl shadow-xl p-8 mb-8 hidden">
            <h3 class="text-2xl font-bold text-gray-800 mb-6">æœå°‹çµæœ</h3>
            <div id="searchResults" class="space-y-4"></div>
        </div>

        <!-- Data Management Section -->
        <div class="grid md:grid-cols-2 gap-8">
            <!-- Import Section -->
            <div class="bg-white rounded-2xl shadow-xl p-8">
                <h3 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <span class="mr-3">ğŸ“¥</span>
                    è³‡æ–™å°å…¥
                </h3>
                <div class="space-y-4">
                    <!-- Import Options -->
                    <div class="grid grid-cols-2 gap-3 mb-4">
                        <button id="fileImportBtn" class="px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center space-x-2">
                            <span>ğŸ“</span>
                            <span>å¾æª”æ¡ˆå°å…¥</span>
                        </button>
                        <button id="textImportBtn" class="px-4 py-2 bg-green-600 text-white rounded-lg hover:bg-green-700 transition-colors flex items-center justify-center space-x-2">
                            <span>âœï¸</span>
                            <span>æ‰‹å‹•è¼¸å…¥</span>
                        </button>
                    </div>
                    
                    <!-- Manual Input Section -->
                    <div id="manualInputSection" class="hidden">
                        <label class="block text-sm font-medium text-gray-700 mb-2">
                            è³‡æ–™æ ¼å¼ï¼šä¸­è—¥åï¼šç—‡ç‹€1,ç—‡ç‹€2,ç—‡ç‹€3
                        </label>
                        <textarea 
                            id="importData" 
                            rows="8" 
                            placeholder="ç¯„ä¾‹ï¼š&#10;ç•¶æ­¸ï¼šè¡€è™›,æœˆç¶“ä¸èª¿,ä¾¿ç§˜&#10;é»ƒèŠªï¼šæ°£è™›,è‡ªæ±—,æ°´è…«&#10;äººåƒï¼šæ°£è™›,å¿ƒæ‚¸,å¤±çœ "
                            class="w-full px-4 py-3 border-2 border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none resize-none"
                        ></textarea>
                        <button id="processImport" class="w-full px-6 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors font-medium mt-3">
                            è™•ç†ä¸¦å°å…¥è³‡æ–™
                        </button>
                    </div>
                    
                    <!-- File Import Status -->
                    <div id="importStatus" class="hidden p-3 rounded-lg">
                        <div class="flex items-center space-x-2">
                            <span id="statusIcon">âœ…</span>
                            <span id="statusText" class="text-sm font-medium"></span>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Current Data Section -->
            <div class="bg-white rounded-2xl shadow-xl p-8">
                <h3 class="text-2xl font-bold text-gray-800 mb-6 flex items-center">
                    <span class="mr-3">ğŸ“Š</span>
                    ç•¶å‰è³‡æ–™åº«
                </h3>
                <div class="space-y-4">
                    <div class="flex justify-between items-center p-4 bg-gray-50 rounded-lg">
                        <span class="text-gray-700">ä¸­è—¥ç¸½æ•¸</span>
                        <span id="herbCount" class="font-bold text-blue-600">0</span>
                    </div>
                    <div class="flex justify-between items-center p-4 bg-gray-50 rounded-lg">
                        <span class="text-gray-700">ç—‡ç‹€ç¸½æ•¸</span>
                        <span id="symptomCount" class="font-bold text-green-600">0</span>
                    </div>
                    <button id="clearData" class="w-full px-6 py-3 bg-red-600 text-white rounded-lg hover:bg-red-700 transition-colors font-medium">
                        æ¸…ç©ºæ‰€æœ‰è³‡æ–™
                    </button>
                </div>
            </div>
        </div>

        <!-- Data Preview Section -->
        <div id="dataPreview" class="bg-white rounded-2xl shadow-xl p-8 mt-8">
            <h3 class="text-2xl font-bold text-gray-800 mb-6">è³‡æ–™é è¦½</h3>
            <div class="grid md:grid-cols-2 gap-8">
                <div>
                    <h4 class="text-lg font-semibold text-gray-700 mb-4">ä¸­è—¥åˆ—è¡¨</h4>
                    <div id="herbsList" class="max-h-64 overflow-y-auto space-y-2"></div>
                </div>
                <div>
                    <h4 class="text-lg font-semibold text-gray-700 mb-4">ç—‡ç‹€åˆ—è¡¨</h4>
                    <div id="symptomsList" class="max-h-64 overflow-y-auto space-y-2"></div>
                </div>
            </div>
        </div>
    </div>



    <input type="file" id="fileInput" accept=".txt,.json" class="hidden">

    <script>
        class TCMDiagnosticTool {
            constructor() {
                this.data = JSON.parse(localStorage.getItem('tcmData')) || {
                    herbs: {}, // ä¸­è—¥ -> [ç—‡ç‹€]
                    symptoms: {} // ç—‡ç‹€ -> [ä¸­è—¥]
                };
                this.initializeEventListeners();
                this.updateUI();
            }

            initializeEventListeners() {
                // Search functionality
                document.getElementById('searchBtn').addEventListener('click', () => this.search());
                document.getElementById('searchInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.search();
                });
                
                // Real-time search suggestions
                document.getElementById('searchInput').addEventListener('input', (e) => {
                    this.showSearchSuggestions(e.target.value);
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#searchInput') && !e.target.closest('#searchSuggestions')) {
                        this.hideSearchSuggestions();
                    }
                });

                // Import/Export
                document.getElementById('exportBtn').addEventListener('click', () => this.exportData());
                document.getElementById('processImport').addEventListener('click', () => this.processImportData());
                document.getElementById('clearData').addEventListener('click', () => this.clearAllData());

                // Import controls
                document.getElementById('fileImportBtn').addEventListener('click', () => this.triggerFileImport());
                document.getElementById('textImportBtn').addEventListener('click', () => this.toggleManualInput());
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileImport(e));
            }

            search() {
                const query = document.getElementById('searchInput').value.trim();
                if (!query) return;

                const results = this.performSearch(query);
                this.displaySearchResults(query, results);
            }

            performSearch(query) {
                const results = {
                    herbResults: [],
                    symptomResults: []
                };

                // Normalize query for better matching
                const normalizedQuery = this.normalizeText(query);
                const queryTerms = this.extractKeywords(normalizedQuery);

                // Advanced similarity calculation with multiple algorithms
                const calculateAdvancedSimilarity = (str1, str2) => {
                    const norm1 = this.normalizeText(str1);
                    const norm2 = this.normalizeText(str2);
                    
                    // 1. Exact match (highest priority)
                    if (norm1 === norm2) return 100;
                    
                    // 2. Contains match
                    if (norm1.includes(norm2) || norm2.includes(norm1)) return 95;
                    
                    // 3. Starts with match
                    if (norm1.startsWith(norm2) || norm2.startsWith(norm1)) return 90;
                    
                    // 4. Ends with match
                    if (norm1.endsWith(norm2) || norm2.endsWith(norm1)) return 85;
                    
                    // 5. Levenshtein distance similarity
                    const levenshteinScore = this.calculateLevenshteinSimilarity(norm1, norm2);
                    
                    // 6. Jaccard similarity for character n-grams
                    const jaccardScore = this.calculateJaccardSimilarity(norm1, norm2);
                    
                    // 7. Keyword matching
                    const keywordScore = this.calculateKeywordSimilarity(str1, queryTerms);
                    
                    // 8. Phonetic similarity (for Chinese characters)
                    const phoneticScore = this.calculatePhoneticSimilarity(norm1, norm2);
                    
                    // Weighted combination of all scores
                    const finalScore = Math.max(
                        levenshteinScore * 0.3,
                        jaccardScore * 0.25,
                        keywordScore * 0.25,
                        phoneticScore * 0.2
                    );
                    
                    return Math.round(finalScore);
                };

                // Search in herbs with advanced scoring
                const herbMatches = [];
                Object.keys(this.data.herbs).forEach(herb => {
                    const similarity = calculateAdvancedSimilarity(herb, query);
                    
                    // Also check symptoms for indirect matches
                    let maxSymptomMatch = 0;
                    this.data.herbs[herb].forEach(symptom => {
                        const symptomSimilarity = calculateAdvancedSimilarity(symptom, query);
                        maxSymptomMatch = Math.max(maxSymptomMatch, symptomSimilarity * 0.7); // Reduce weight for indirect matches
                    });
                    
                    const finalScore = Math.max(similarity, maxSymptomMatch);
                    
                    if (finalScore >= 30) { // Lower threshold for more results
                        herbMatches.push({
                            name: herb,
                            symptoms: this.data.herbs[herb],
                            score: finalScore,
                            matchType: similarity > maxSymptomMatch ? 'direct' : 'indirect'
                        });
                    }
                });

                // Search in symptoms with advanced scoring
                const symptomMatches = [];
                Object.keys(this.data.symptoms).forEach(symptom => {
                    const similarity = calculateAdvancedSimilarity(symptom, query);
                    
                    // Also check related herbs for indirect matches
                    let maxHerbMatch = 0;
                    this.data.symptoms[symptom].forEach(herb => {
                        const herbSimilarity = calculateAdvancedSimilarity(herb, query);
                        maxHerbMatch = Math.max(maxHerbMatch, herbSimilarity * 0.7);
                    });
                    
                    const finalScore = Math.max(similarity, maxHerbMatch);
                    
                    if (finalScore >= 30) {
                        symptomMatches.push({
                            name: symptom,
                            herbs: this.data.symptoms[symptom],
                            score: finalScore,
                            matchType: similarity > maxHerbMatch ? 'direct' : 'indirect'
                        });
                    }
                });

                // Advanced sorting with multiple criteria
                const advancedSort = (a, b) => {
                    // Primary: Score
                    if (a.score !== b.score) return b.score - a.score;
                    
                    // Secondary: Direct matches first
                    if (a.matchType !== b.matchType) {
                        return a.matchType === 'direct' ? -1 : 1;
                    }
                    
                    // Tertiary: Shorter names (more specific) first
                    return a.name.length - b.name.length;
                };

                results.herbResults = herbMatches
                    .sort(advancedSort)
                    .slice(0, 15); // Increased limit

                results.symptomResults = symptomMatches
                    .sort(advancedSort)
                    .slice(0, 15); // Increased limit

                return results;
            }

            // Text normalization for better matching
            normalizeText(text) {
                return text.toLowerCase()
                    .replace(/\s+/g, '') // Remove spaces
                    .replace(/[ï¼Œã€‚ã€ï¼›ï¼šï¼ï¼Ÿ]/g, '') // Remove Chinese punctuation
                    .replace(/[,.\-;:!?]/g, ''); // Remove English punctuation
            }

            // Extract keywords from query
            extractKeywords(query) {
                // Split by common separators and filter out short terms
                return query.split(/[ï¼Œã€‚ã€ï¼›ï¼š\s,.\-;:]+/)
                    .filter(term => term.length > 0)
                    .map(term => term.trim());
            }

            // Levenshtein distance similarity
            calculateLevenshteinSimilarity(str1, str2) {
                const matrix = [];
                const len1 = str1.length;
                const len2 = str2.length;

                for (let i = 0; i <= len1; i++) {
                    matrix[i] = [i];
                }

                for (let j = 0; j <= len2; j++) {
                    matrix[0][j] = j;
                }

                for (let i = 1; i <= len1; i++) {
                    for (let j = 1; j <= len2; j++) {
                        if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }

                const maxLen = Math.max(len1, len2);
                return maxLen === 0 ? 100 : ((maxLen - matrix[len1][len2]) / maxLen) * 100;
            }

            // Jaccard similarity for character n-grams
            calculateJaccardSimilarity(str1, str2, n = 2) {
                const getNGrams = (str, n) => {
                    const ngrams = new Set();
                    for (let i = 0; i <= str.length - n; i++) {
                        ngrams.add(str.substring(i, i + n));
                    }
                    return ngrams;
                };

                const ngrams1 = getNGrams(str1, n);
                const ngrams2 = getNGrams(str2, n);
                
                const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                const union = new Set([...ngrams1, ...ngrams2]);
                
                return union.size === 0 ? 0 : (intersection.size / union.size) * 100;
            }

            // Keyword matching similarity
            calculateKeywordSimilarity(text, keywords) {
                if (keywords.length === 0) return 0;
                
                const normalizedText = this.normalizeText(text);
                let matches = 0;
                
                keywords.forEach(keyword => {
                    const normalizedKeyword = this.normalizeText(keyword);
                    if (normalizedText.includes(normalizedKeyword)) {
                        matches++;
                    }
                });
                
                return (matches / keywords.length) * 100;
            }

            // Simple phonetic similarity for Chinese characters
            calculatePhoneticSimilarity(str1, str2) {
                // This is a simplified version - in a real implementation,
                // you would use a proper Chinese phonetic algorithm
                const getPhoneticCode = (char) => {
                    // Simplified mapping of some common characters
                    const phoneticMap = {
                        'æ°£': 'qi', 'è¡€': 'xue', 'è™›': 'xu', 'å¯¦': 'shi',
                        'ç†±': 're', 'å¯’': 'han', 'æ¿•': 'shi', 'ç‡¥': 'zao',
                        'é¢¨': 'feng', 'ç«': 'huo', 'ç—°': 'tan', 'ç˜€': 'yu'
                    };
                    return phoneticMap[char] || char;
                };
                
                const phonetic1 = str1.split('').map(getPhoneticCode).join('');
                const phonetic2 = str2.split('').map(getPhoneticCode).join('');
                
                return this.calculateLevenshteinSimilarity(phonetic1, phonetic2) * 0.8;
            }

            displaySearchResults(query, results) {
                const resultsSection = document.getElementById('resultsSection');
                const searchResults = document.getElementById('searchResults');
                
                resultsSection.classList.remove('hidden');
                searchResults.innerHTML = '';

                if (results.herbResults.length === 0 && results.symptomResults.length === 0) {
                    searchResults.innerHTML = `
                        <div class="text-center py-8 text-gray-500">
                            <div class="text-4xl mb-4">ğŸ”</div>
                            <p class="text-lg">æœªæ‰¾åˆ°ç›¸é—œçµæœ</p>
                            <p class="text-sm mt-2">è«‹å˜—è©¦å…¶ä»–é—œéµå­—æˆ–æª¢æŸ¥æ‹¼å¯«</p>
                        </div>
                    `;
                    return;
                }

                // Display herb results
                if (results.herbResults.length > 0) {
                    const herbSection = document.createElement('div');
                    herbSection.className = 'mb-8';
                    herbSection.innerHTML = `
                        <h4 class="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                            <span class="mr-2">ğŸŒ¿</span>
                            ä¸­è—¥è³‡è¨Š
                        </h4>
                    `;

                    results.herbResults.forEach((herb, index) => {
                        const herbCard = document.createElement('div');
                        const matchBadge = herb.score >= 95 ? 'å®Œå…¨åŒ¹é…' : herb.score >= 80 ? 'é«˜åº¦åŒ¹é…' : herb.score >= 60 ? 'ä¸­åº¦åŒ¹é…' : 'ç›¸é—œåŒ¹é…';
                        const badgeColor = herb.score >= 95 ? 'bg-red-100 text-red-800' : herb.score >= 80 ? 'bg-orange-100 text-orange-800' : herb.score >= 60 ? 'bg-yellow-100 text-yellow-800' : 'bg-blue-100 text-blue-800';
                        const matchTypeIcon = herb.matchType === 'direct' ? 'ğŸ¯' : 'ğŸ”—';
                        const matchTypeText = herb.matchType === 'direct' ? 'ç›´æ¥åŒ¹é…' : 'é–“æ¥åŒ¹é…';
                        
                        herbCard.className = 'bg-green-50 border-l-4 border-green-500 p-6 rounded-lg mb-4 relative';
                        herbCard.innerHTML = `
                            <div class="flex justify-between items-start mb-3">
                                <h5 class="text-lg font-bold text-green-800">${herb.name}</h5>
                                <div class="flex items-center space-x-2">
                                    <span class="px-2 py-1 ${badgeColor} rounded-full text-xs font-medium">${matchBadge}</span>
                                    <span class="px-2 py-1 bg-purple-100 text-purple-800 rounded-full text-xs">${matchTypeIcon} ${matchTypeText}</span>
                                    <span class="px-2 py-1 bg-gray-100 text-gray-600 rounded-full text-xs">æ’å ${index + 1}</span>
                                    <span class="px-2 py-1 bg-indigo-100 text-indigo-800 rounded-full text-xs font-mono">${herb.score}%</span>
                                </div>
                            </div>
                            <div class="space-y-2">
                                <p class="text-sm text-gray-600 font-medium">é©ç”¨ç—‡ç‹€ï¼š</p>
                                <div class="flex flex-wrap gap-2">
                                    ${herb.symptoms.map(symptom => {
                                        const isHighlighted = this.normalizeText(symptom).includes(this.normalizeText(query)) || 
                                                            this.normalizeText(query).includes(this.normalizeText(symptom));
                                        return `<span class="px-3 py-1 ${isHighlighted ? 'bg-yellow-200 text-yellow-900 font-medium' : 'bg-green-100 text-green-800'} rounded-full text-sm">${symptom}</span>`;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                        herbSection.appendChild(herbCard);
                    });

                    searchResults.appendChild(herbSection);
                }

                // Display symptom results
                if (results.symptomResults.length > 0) {
                    const symptomSection = document.createElement('div');
                    symptomSection.innerHTML = `
                        <h4 class="text-xl font-semibold text-gray-800 mb-4 flex items-center">
                            <span class="mr-2">ğŸ©º</span>
                            ç—‡ç‹€å°æ‡‰ä¸­è—¥
                        </h4>
                    `;

                    results.symptomResults.forEach((symptom, index) => {
                        const symptomCard = document.createElement('div');
                        const matchBadge = symptom.score >= 95 ? 'å®Œå…¨åŒ¹é…' : symptom.score >= 80 ? 'é«˜åº¦åŒ¹é…' : symptom.score >= 60 ? 'ä¸­åº¦åŒ¹é…' : 'ç›¸é—œåŒ¹é…';
                        const badgeColor = symptom.score >= 95 ? 'bg-red-100 text-red-800' : symptom.score >= 80 ? 'bg-orange-100 text-orange-800' : symptom.score >= 60 ? 'bg-yellow-100 text-yellow-800' : 'bg-blue-100 text-blue-800';
                        const matchTypeIcon = symptom.matchType === 'direct' ? 'ğŸ¯' : 'ğŸ”—';
                        const matchTypeText = symptom.matchType === 'direct' ? 'ç›´æ¥åŒ¹é…' : 'é–“æ¥åŒ¹é…';
                        
                        symptomCard.className = 'bg-blue-50 border-l-4 border-blue-500 p-6 rounded-lg mb-4 relative';
                        symptomCard.innerHTML = `
                            <div class="flex justify-between items-start mb-3">
                                <h5 class="text-lg font-bold text-blue-800">${symptom.name}</h5>
                                <div class="flex items-center space-x-2">
                                    <span class="px-2 py-1 ${badgeColor} rounded-full text-xs font-medium">${matchBadge}</span>
                                    <span class="px-2 py-1 bg-purple-100 text-purple-800 rounded-full text-xs">${matchTypeIcon} ${matchTypeText}</span>
                                    <span class="px-2 py-1 bg-gray-100 text-gray-600 rounded-full text-xs">æ’å ${index + 1}</span>
                                    <span class="px-2 py-1 bg-indigo-100 text-indigo-800 rounded-full text-xs font-mono">${symptom.score}%</span>
                                </div>
                            </div>
                            <div class="space-y-2">
                                <p class="text-sm text-gray-600 font-medium">æ¨è–¦ä¸­è—¥ï¼š</p>
                                <div class="flex flex-wrap gap-2">
                                    ${symptom.herbs.map(herb => {
                                        const isHighlighted = this.normalizeText(herb).includes(this.normalizeText(query)) || 
                                                            this.normalizeText(query).includes(this.normalizeText(herb));
                                        return `<span class="px-3 py-1 ${isHighlighted ? 'bg-yellow-200 text-yellow-900 font-medium' : 'bg-blue-100 text-blue-800'} rounded-full text-sm">${herb}</span>`;
                                    }).join('')}
                                </div>
                            </div>
                        `;
                        symptomSection.appendChild(symptomCard);
                    });

                    searchResults.appendChild(symptomSection);
                }
            }

            processImportData() {
                const importText = document.getElementById('importData').value.trim();
                if (!importText) {
                    this.showImportStatus('âš ï¸', 'è«‹è¼¸å…¥è¦å°å…¥çš„è³‡æ–™', 'bg-yellow-100 text-yellow-800');
                    return;
                }

                this.showImportStatus('â³', 'æ­£åœ¨è™•ç†è³‡æ–™...', 'bg-blue-100 text-blue-800');

                const lines = importText.split('\n').filter(line => line.trim());
                let successCount = 0;

                lines.forEach(line => {
                    const parts = line.split('ï¼š');
                    if (parts.length === 2) {
                        const herb = parts[0].trim();
                        const symptoms = parts[1].split(',').map(s => s.trim()).filter(s => s);
                        
                        if (herb && symptoms.length > 0) {
                            this.addHerbData(herb, symptoms);
                            successCount++;
                        }
                    }
                });

                this.saveData();
                this.updateUI();
                document.getElementById('importData').value = '';
                
                this.showImportStatus('âœ…', `æˆåŠŸå°å…¥ ${successCount} æ¢ä¸­è—¥è³‡æ–™`, 'bg-green-100 text-green-800');
                
                // Hide manual input section and status after success
                setTimeout(() => {
                    document.getElementById('manualInputSection').classList.add('hidden');
                    document.getElementById('textImportBtn').innerHTML = '<span>âœï¸</span><span>æ‰‹å‹•è¼¸å…¥</span>';
                    document.getElementById('importStatus').classList.add('hidden');
                }, 2000);
            }

            addHerbData(herb, symptoms) {
                // Add to herbs data
                if (!this.data.herbs[herb]) {
                    this.data.herbs[herb] = [];
                }
                
                symptoms.forEach(symptom => {
                    if (!this.data.herbs[herb].includes(symptom)) {
                        this.data.herbs[herb].push(symptom);
                    }
                    
                    // Add to symptoms data
                    if (!this.data.symptoms[symptom]) {
                        this.data.symptoms[symptom] = [];
                    }
                    if (!this.data.symptoms[symptom].includes(herb)) {
                        this.data.symptoms[symptom].push(herb);
                    }
                });
            }

            toggleManualInput() {
                const manualSection = document.getElementById('manualInputSection');
                const isHidden = manualSection.classList.contains('hidden');
                
                if (isHidden) {
                    manualSection.classList.remove('hidden');
                    document.getElementById('textImportBtn').textContent = 'âœï¸ éš±è—è¼¸å…¥';
                } else {
                    manualSection.classList.add('hidden');
                    document.getElementById('textImportBtn').innerHTML = '<span>âœï¸</span><span>æ‰‹å‹•è¼¸å…¥</span>';
                }
            }

            triggerFileImport() {
                document.getElementById('fileInput').click();
            }

            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.showImportStatus('â³', 'æ­£åœ¨è™•ç†æª”æ¡ˆ...', 'bg-blue-100 text-blue-800');

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        let successCount = 0;
                        
                        if (file.name.endsWith('.json')) {
                            const importedData = JSON.parse(content);
                            this.data = importedData;
                            successCount = Object.keys(importedData.herbs || {}).length;
                        } else {
                            // Process text file
                            const lines = content.split('\n').filter(line => line.trim());
                            lines.forEach(line => {
                                const parts = line.split('ï¼š');
                                if (parts.length === 2) {
                                    const herb = parts[0].trim();
                                    const symptoms = parts[1].split(',').map(s => s.trim()).filter(s => s);
                                    
                                    if (herb && symptoms.length > 0) {
                                        this.addHerbData(herb, symptoms);
                                        successCount++;
                                    }
                                }
                            });
                        }
                        
                        this.saveData();
                        this.updateUI();
                        this.showImportStatus('âœ…', `æˆåŠŸå°å…¥ ${successCount} æ¢è³‡æ–™`, 'bg-green-100 text-green-800');
                        
                        // Hide status after 3 seconds
                        setTimeout(() => {
                            document.getElementById('importStatus').classList.add('hidden');
                        }, 3000);
                        
                    } catch (error) {
                        this.showImportStatus('âŒ', 'æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆå…§å®¹', 'bg-red-100 text-red-800');
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            showImportStatus(icon, text, className) {
                const statusDiv = document.getElementById('importStatus');
                const statusIcon = document.getElementById('statusIcon');
                const statusText = document.getElementById('statusText');
                
                statusIcon.textContent = icon;
                statusText.textContent = text;
                statusDiv.className = `p-3 rounded-lg ${className}`;
                statusDiv.classList.remove('hidden');
            }

            exportData() {
                const dataStr = JSON.stringify(this.data, null, 2);
                const dataBlob = new Blob([dataStr], { type: 'application/json' });
                const url = URL.createObjectURL(dataBlob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `ä¸­é†«è³‡æ–™å‚™ä»½_${new Date().toISOString().split('T')[0]}.json`;
                link.click();
                
                URL.revokeObjectURL(url);
            }

            clearAllData() {
                if (confirm('ç¢ºå®šè¦æ¸…ç©ºæ‰€æœ‰è³‡æ–™å—ï¼Ÿæ­¤æ“ä½œç„¡æ³•å¾©åŸã€‚')) {
                    this.data = { herbs: {}, symptoms: {} };
                    this.saveData();
                    this.updateUI();
                    document.getElementById('resultsSection').classList.add('hidden');
                    alert('æ‰€æœ‰è³‡æ–™å·²æ¸…ç©º');
                }
            }

            updateUI() {
                const herbCount = Object.keys(this.data.herbs).length;
                const symptomCount = Object.keys(this.data.symptoms).length;
                
                document.getElementById('herbCount').textContent = herbCount;
                document.getElementById('symptomCount').textContent = symptomCount;
                
                this.updateDataPreview();
            }

            updateDataPreview() {
                const herbsList = document.getElementById('herbsList');
                const symptomsList = document.getElementById('symptomsList');
                
                herbsList.innerHTML = '';
                symptomsList.innerHTML = '';
                
                // Display herbs
                Object.keys(this.data.herbs).slice(0, 10).forEach(herb => {
                    const herbItem = document.createElement('div');
                    herbItem.className = 'p-3 bg-green-50 rounded-lg border border-green-200';
                    herbItem.innerHTML = `
                        <div class="font-medium text-green-800">${herb}</div>
                        <div class="text-sm text-green-600 mt-1">
                            ${this.data.herbs[herb].slice(0, 3).join(', ')}
                            ${this.data.herbs[herb].length > 3 ? '...' : ''}
                        </div>
                    `;
                    herbsList.appendChild(herbItem);
                });
                
                // Display symptoms
                Object.keys(this.data.symptoms).slice(0, 10).forEach(symptom => {
                    const symptomItem = document.createElement('div');
                    symptomItem.className = 'p-3 bg-blue-50 rounded-lg border border-blue-200';
                    symptomItem.innerHTML = `
                        <div class="font-medium text-blue-800">${symptom}</div>
                        <div class="text-sm text-blue-600 mt-1">
                            ${this.data.symptoms[symptom].slice(0, 3).join(', ')}
                            ${this.data.symptoms[symptom].length > 3 ? '...' : ''}
                        </div>
                    `;
                    symptomsList.appendChild(symptomItem);
                });
                
                if (Object.keys(this.data.herbs).length > 10) {
                    const moreItem = document.createElement('div');
                    moreItem.className = 'p-3 text-center text-gray-500 text-sm';
                    moreItem.textContent = `é‚„æœ‰ ${Object.keys(this.data.herbs).length - 10} å€‹ä¸­è—¥...`;
                    herbsList.appendChild(moreItem);
                }
                
                if (Object.keys(this.data.symptoms).length > 10) {
                    const moreItem = document.createElement('div');
                    moreItem.className = 'p-3 text-center text-gray-500 text-sm';
                    moreItem.textContent = `é‚„æœ‰ ${Object.keys(this.data.symptoms).length - 10} å€‹ç—‡ç‹€...`;
                    symptomsList.appendChild(moreItem);
                }
            }

            saveData() {
                localStorage.setItem('tcmData', JSON.stringify(this.data));
            }

            // Show real-time search suggestions
            showSearchSuggestions(query) {
                const suggestionsDiv = document.getElementById('searchSuggestions');
                
                if (!query || query.length < 1) {
                    this.hideSearchSuggestions();
                    return;
                }

                const suggestions = this.generateSuggestions(query);
                
                if (suggestions.length === 0) {
                    this.hideSearchSuggestions();
                    return;
                }

                suggestionsDiv.innerHTML = '';
                suggestions.forEach(suggestion => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'px-4 py-3 hover:bg-gray-50 cursor-pointer border-b border-gray-100 last:border-b-0 flex items-center justify-between';
                    suggestionItem.innerHTML = `
                        <div class="flex items-center space-x-3">
                            <span class="text-lg">${suggestion.icon}</span>
                            <div>
                                <div class="font-medium text-gray-800">${this.highlightMatch(suggestion.text, query)}</div>
                                <div class="text-xs text-gray-500">${suggestion.type} â€¢ ${suggestion.count} å€‹ç›¸é—œé …ç›®</div>
                            </div>
                        </div>
                        <div class="text-xs text-gray-400">${suggestion.score}%</div>
                    `;
                    
                    suggestionItem.addEventListener('click', () => {
                        document.getElementById('searchInput').value = suggestion.text;
                        this.hideSearchSuggestions();
                        this.search();
                    });
                    
                    suggestionsDiv.appendChild(suggestionItem);
                });

                suggestionsDiv.classList.remove('hidden');
            }

            // Generate search suggestions
            generateSuggestions(query) {
                const suggestions = [];
                const normalizedQuery = this.normalizeText(query);

                // Get suggestions from herbs
                Object.keys(this.data.herbs).forEach(herb => {
                    const similarity = this.calculateAdvancedSimilarity(herb, query);
                    if (similarity >= 40) {
                        suggestions.push({
                            text: herb,
                            type: 'ä¸­è—¥',
                            icon: 'ğŸŒ¿',
                            score: Math.round(similarity),
                            count: this.data.herbs[herb].length,
                            category: 'herb'
                        });
                    }
                });

                // Get suggestions from symptoms
                Object.keys(this.data.symptoms).forEach(symptom => {
                    const similarity = this.calculateAdvancedSimilarity(symptom, query);
                    if (similarity >= 40) {
                        suggestions.push({
                            text: symptom,
                            type: 'ç—‡ç‹€',
                            icon: 'ğŸ©º',
                            score: Math.round(similarity),
                            count: this.data.symptoms[symptom].length,
                            category: 'symptom'
                        });
                    }
                });

                // Sort by similarity score and limit results
                return suggestions
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 8);
            }

            // Highlight matching parts in suggestions
            highlightMatch(text, query) {
                const normalizedText = this.normalizeText(text);
                const normalizedQuery = this.normalizeText(query);
                
                if (normalizedText.includes(normalizedQuery)) {
                    const index = normalizedText.indexOf(normalizedQuery);
                    const before = text.substring(0, index);
                    const match = text.substring(index, index + query.length);
                    const after = text.substring(index + query.length);
                    return `${before}<mark class="bg-yellow-200 px-1 rounded">${match}</mark>${after}`;
                }
                
                return text;
            }

            // Hide search suggestions
            hideSearchSuggestions() {
                document.getElementById('searchSuggestions').classList.add('hidden');
            }

            // Calculate advanced similarity (reused from search)
            calculateAdvancedSimilarity(str1, str2) {
                const norm1 = this.normalizeText(str1);
                const norm2 = this.normalizeText(str2);
                
                if (norm1 === norm2) return 100;
                if (norm1.includes(norm2) || norm2.includes(norm1)) return 95;
                if (norm1.startsWith(norm2) || norm2.startsWith(norm1)) return 90;
                if (norm1.endsWith(norm2) || norm2.endsWith(norm1)) return 85;
                
                const levenshteinScore = this.calculateLevenshteinSimilarity(norm1, norm2);
                const jaccardScore = this.calculateJaccardSimilarity(norm1, norm2);
                
                return Math.max(levenshteinScore * 0.6, jaccardScore * 0.4);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new TCMDiagnosticTool();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'96519f3f93a0094e',t:'MTc1MzUwOTA1My4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
