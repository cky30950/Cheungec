<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­é†«è¨ºç—‡è¼”åŠ©å·¥å…·</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Noto+Sans+TC:wght@300;400;500;600;700&display=swap');
        body { font-family: 'Noto Sans TC', sans-serif; }
        .glass-effect {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        .search-highlight {
            background: linear-gradient(120deg, #fbbf24 0%, #f59e0b 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }
    </style>
</head>
<body class="bg-gradient-to-br from-blue-50 via-indigo-50 to-purple-50 min-h-screen">
    <!-- Header -->
    <header class="bg-white shadow-sm">
        <div class="max-w-4xl mx-auto px-4 py-3">
            <div class="flex items-center justify-between">
                <h1 class="text-xl font-bold text-gray-800">ä¸­è—¥è³‡æ–™åº«</h1>
                <button id="backupBtn" class="px-3 py-1.5 bg-purple-600 text-white rounded-md hover:bg-purple-700 transition-colors text-sm">
                    ğŸ’¾ å‚™ä»½è³‡æ–™
                </button>
            </div>
        </div>
    </header>

    <div class="max-w-4xl mx-auto px-4 py-6">
        <!-- Search Section -->
        <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
            <div class="relative">
                <input 
                    type="text" 
                    id="searchInput" 
                    placeholder="æœå°‹ç—‡ç‹€æˆ–ä¸­è—¥..." 
                    class="w-full px-4 py-3 border border-gray-300 rounded-lg focus:border-blue-500 focus:outline-none"
                    autocomplete="off"
                >
                <button id="searchBtn" class="absolute right-2 top-2 px-4 py-1.5 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors text-sm">
                    æœå°‹
                </button>
                <div id="searchSuggestions" class="absolute top-full left-0 right-0 bg-white border border-gray-200 rounded-lg shadow-lg mt-1 hidden z-10 max-h-64 overflow-y-auto"></div>
            </div>
        </div>

        <!-- Results Section -->
        <div id="resultsSection" class="bg-white rounded-lg shadow-sm p-6 mb-6 hidden">
            <div id="searchResults" class="space-y-4"></div>
        </div>

        <!-- Data Management Section -->
        <div class="bg-white rounded-lg shadow-sm p-6 mb-6">
            <div class="flex flex-wrap gap-3 mb-4">
                <button id="fileImportBtn" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors text-sm">
                    å°å…¥æª”æ¡ˆ
                </button>
                <button id="textImportBtn" class="px-4 py-2 bg-green-600 text-white rounded-md hover:bg-green-700 transition-colors text-sm">
                    æ‰‹å‹•è¼¸å…¥
                </button>
                <div class="ml-auto flex items-center space-x-4 text-sm text-gray-600">
                    <span>ä¸­è—¥: <span id="herbCount" class="font-medium">0</span></span>
                    <span>ç—‡ç‹€: <span id="symptomCount" class="font-medium">0</span></span>
                </div>
            </div>
            
            <!-- Manual Input Section -->
            <div id="manualInputSection" class="hidden">
                <textarea 
                    id="importData" 
                    rows="6" 
                    placeholder="æ ¼å¼ï¼šä¸­è—¥åï¼šç—‡ç‹€1,ç—‡ç‹€2,ç—‡ç‹€3&#10;ç¯„ä¾‹ï¼šç•¶æ­¸ï¼šè¡€è™›,æœˆç¶“ä¸èª¿,ä¾¿ç§˜"
                    class="w-full px-3 py-2 border border-gray-300 rounded-md focus:border-blue-500 focus:outline-none resize-none text-sm mb-3"
                ></textarea>
                <button id="processImport" class="px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 transition-colors text-sm">
                    å°å…¥è³‡æ–™
                </button>
            </div>
            
            <!-- File Import Status -->
            <div id="importStatus" class="hidden p-3 rounded-md">
                <div class="flex items-center space-x-2">
                    <span id="statusIcon">âœ…</span>
                    <span id="statusText" class="text-sm"></span>
                </div>
            </div>
        </div>


    </div>

    <!-- Backup Modal -->
    <div id="backupModal" class="fixed inset-0 bg-black bg-opacity-50 hidden items-center justify-center z-50">
        <div class="bg-white rounded-lg p-6 max-w-md w-full mx-4">
            <div class="flex items-center justify-between mb-6">
                <h3 class="text-xl font-bold text-gray-800 flex items-center">
                    ğŸ’¾ è³‡æ–™å‚™ä»½
                </h3>
                <button id="closeBackupModal" class="text-gray-400 hover:text-gray-600 text-xl">Ã—</button>
            </div>
            
            <!-- Backup Info -->
            <div class="bg-gray-50 rounded-lg p-4 mb-6">
                <div class="grid grid-cols-2 gap-4 text-sm">
                    <div class="text-center">
                        <div class="text-2xl font-bold text-blue-600" id="backupHerbCount">0</div>
                        <div class="text-gray-600">ä¸­è—¥</div>
                    </div>
                    <div class="text-center">
                        <div class="text-2xl font-bold text-green-600" id="backupSymptomCount">0</div>
                        <div class="text-gray-600">ç—‡ç‹€</div>
                    </div>
                </div>
                <div class="text-center mt-3 text-xs text-gray-500">
                    æœ€å¾Œæ›´æ–°ï¼š<span id="lastUpdateTime">-</span>
                </div>
            </div>
            
            <!-- Backup Options -->
            <div class="space-y-3">
                <button id="downloadBackup" class="w-full px-4 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors flex items-center justify-center space-x-2">
                    <span>ğŸ“¥</span>
                    <span>ä¸‹è¼‰å‚™ä»½æª”æ¡ˆ</span>
                </button>
                
                <button id="copyBackup" class="w-full px-4 py-3 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors flex items-center justify-center space-x-2">
                    <span>ğŸ“‹</span>
                    <span>è¤‡è£½åˆ°å‰ªè²¼ç°¿</span>
                </button>
                
                <div class="border-t pt-3">
                    <div class="text-sm text-gray-600 mb-2">æˆ–è€…æ¢å¾©å‚™ä»½ï¼š</div>
                    <button id="restoreBackup" class="w-full px-4 py-2 bg-orange-600 text-white rounded-lg hover:bg-orange-700 transition-colors flex items-center justify-center space-x-2">
                        <span>ğŸ“¤</span>
                        <span>é¸æ“‡å‚™ä»½æª”æ¡ˆæ¢å¾©</span>
                    </button>
                </div>
            </div>
            
            <!-- Status Message -->
            <div id="backupStatus" class="hidden mt-4 p-3 rounded-lg text-sm">
                <div class="flex items-center space-x-2">
                    <span id="backupStatusIcon">âœ…</span>
                    <span id="backupStatusText"></span>
                </div>
            </div>
        </div>
    </div>

    <input type="file" id="fileInput" accept=".txt,.json" class="hidden">
    <input type="file" id="backupFileInput" accept=".json" class="hidden">

    <script>
        class TCMDiagnosticTool {
            constructor() {
                this.data = JSON.parse(localStorage.getItem('tcmData')) || {
                    herbs: {}, // ä¸­è—¥ -> [ç—‡ç‹€]
                    symptoms: {} // ç—‡ç‹€ -> [ä¸­è—¥]
                };
                this.initializeEventListeners();
                this.updateUI();
            }

            initializeEventListeners() {
                // Search functionality
                document.getElementById('searchBtn').addEventListener('click', () => this.search());
                document.getElementById('searchInput').addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') this.search();
                });
                
                // Real-time search suggestions
                document.getElementById('searchInput').addEventListener('input', (e) => {
                    this.showSearchSuggestions(e.target.value);
                });
                
                // Hide suggestions when clicking outside
                document.addEventListener('click', (e) => {
                    if (!e.target.closest('#searchInput') && !e.target.closest('#searchSuggestions')) {
                        this.hideSearchSuggestions();
                    }
                });

                // Backup functionality
                document.getElementById('backupBtn').addEventListener('click', () => this.showBackupModal());
                document.getElementById('processImport').addEventListener('click', () => this.processImportData());

                // Import controls
                document.getElementById('fileImportBtn').addEventListener('click', () => this.triggerFileImport());
                document.getElementById('textImportBtn').addEventListener('click', () => this.toggleManualInput());
                document.getElementById('fileInput').addEventListener('change', (e) => this.handleFileImport(e));

                // Backup modal controls
                document.getElementById('closeBackupModal').addEventListener('click', () => this.hideBackupModal());
                document.getElementById('downloadBackup').addEventListener('click', () => this.downloadBackup());
                document.getElementById('copyBackup').addEventListener('click', () => this.copyBackupToClipboard());
                document.getElementById('restoreBackup').addEventListener('click', () => this.triggerBackupRestore());
                document.getElementById('backupFileInput').addEventListener('change', (e) => this.handleBackupRestore(e));
            }

            search() {
                const query = document.getElementById('searchInput').value.trim();
                if (!query) return;

                const results = this.performSearch(query);
                this.displaySearchResults(query, results);
            }

            performSearch(query) {
                const results = {
                    herbResults: [],
                    symptomResults: [],
                    combinationResults: [],
                    relatedResults: []
                };

                // Enhanced query processing
                const processedQuery = this.processSearchQuery(query);
                const { 
                    normalizedQuery, 
                    queryTerms, 
                    synonyms, 
                    categories,
                    isMultiTerm,
                    searchIntent
                } = processedQuery;

                // AI-powered similarity calculation with context awareness
                const calculateIntelligentSimilarity = (str1, str2, context = {}) => {
                    const norm1 = this.normalizeText(str1);
                    const norm2 = this.normalizeText(str2);
                    
                    let baseScore = 0;
                    let contextBonus = 0;
                    
                    // 1. Exact match (highest priority)
                    if (norm1 === norm2) baseScore = 100;
                    
                    // 2. Semantic similarity (TCM-specific)
                    else if (this.checkSemanticSimilarity(str1, str2)) baseScore = 95;
                    
                    // 3. Contains match with position weighting
                    else if (norm1.includes(norm2) || norm2.includes(norm1)) {
                        const position = norm1.indexOf(norm2);
                        baseScore = position === 0 ? 92 : 88; // Higher score for prefix matches
                    }
                    
                    // 4. Fuzzy matching algorithms combination
                    else {
                        const levenshteinScore = this.calculateLevenshteinSimilarity(norm1, norm2);
                        const jaccardScore = this.calculateJaccardSimilarity(norm1, norm2);
                        const damerauScore = this.calculateDamerauLevenshteinSimilarity(norm1, norm2);
                        const soundexScore = this.calculateSoundexSimilarity(str1, str2);
                        const metaphoneScore = this.calculateMetaphoneSimilarity(str1, str2);
                        
                        // Weighted combination with adaptive weights
                        baseScore = Math.max(
                            levenshteinScore * 0.25,
                            jaccardScore * 0.20,
                            damerauScore * 0.25,
                            soundexScore * 0.15,
                            metaphoneScore * 0.15
                        );
                    }
                    
                    // Context-aware scoring bonuses
                    if (context.category && this.getCategoryMatch(str1, context.category)) {
                        contextBonus += 10;
                    }
                    
                    if (context.relatedTerms && this.hasRelatedTerms(str1, context.relatedTerms)) {
                        contextBonus += 5;
                    }
                    
                    // Frequency-based relevance (popular terms get slight boost)
                    const frequencyBonus = this.getFrequencyBonus(str1);
                    
                    return Math.min(100, Math.round(baseScore + contextBonus + frequencyBonus));
                };

                // Multi-dimensional search with intent recognition
                if (searchIntent === 'combination') {
                    // Handle combination queries like "ç•¶æ­¸ + å·èŠ"
                    results.combinationResults = this.searchCombinations(queryTerms);
                } else if (searchIntent === 'symptom_cluster') {
                    // Handle symptom cluster queries
                    results.relatedResults = this.searchSymptomClusters(queryTerms);
                }

                // Enhanced herb search with semantic understanding
                const herbMatches = [];
                Object.keys(this.data.herbs).forEach(herb => {
                    const directSimilarity = calculateIntelligentSimilarity(herb, query, {
                        category: 'herb',
                        relatedTerms: queryTerms
                    });
                    
                    // Multi-level indirect matching
                    let maxSymptomMatch = 0;
                    let symptomMatchDetails = [];
                    
                    this.data.herbs[herb].forEach(symptom => {
                        const symptomSimilarity = calculateIntelligentSimilarity(symptom, query, {
                            category: 'symptom',
                            relatedTerms: queryTerms
                        });
                        
                        if (symptomSimilarity > maxSymptomMatch) {
                            maxSymptomMatch = symptomSimilarity;
                        }
                        
                        if (symptomSimilarity >= 40) {
                            symptomMatchDetails.push({
                                symptom,
                                score: symptomSimilarity
                            });
                        }
                    });
                    
                    // Weighted final score with decay for indirect matches
                    const indirectScore = maxSymptomMatch * 0.75;
                    const finalScore = Math.max(directSimilarity, indirectScore);
                    
                    // Dynamic threshold based on query complexity
                    const threshold = isMultiTerm ? 25 : 30;
                    
                    if (finalScore >= threshold) {
                        herbMatches.push({
                            name: herb,
                            symptoms: this.data.herbs[herb],
                            score: finalScore,
                            directScore: directSimilarity,
                            indirectScore: indirectScore,
                            matchType: directSimilarity > indirectScore ? 'direct' : 'indirect',
                            matchDetails: symptomMatchDetails,
                            relevanceFactors: this.getRelevanceFactors(herb, query, queryTerms)
                        });
                    }
                });

                // Enhanced symptom search with clustering
                const symptomMatches = [];
                Object.keys(this.data.symptoms).forEach(symptom => {
                    const directSimilarity = calculateIntelligentSimilarity(symptom, query, {
                        category: 'symptom',
                        relatedTerms: queryTerms
                    });
                    
                    let maxHerbMatch = 0;
                    let herbMatchDetails = [];
                    
                    this.data.symptoms[symptom].forEach(herb => {
                        const herbSimilarity = calculateIntelligentSimilarity(herb, query, {
                            category: 'herb',
                            relatedTerms: queryTerms
                        });
                        
                        if (herbSimilarity > maxHerbMatch) {
                            maxHerbMatch = herbSimilarity;
                        }
                        
                        if (herbSimilarity >= 40) {
                            herbMatchDetails.push({
                                herb,
                                score: herbSimilarity
                            });
                        }
                    });
                    
                    const indirectScore = maxHerbMatch * 0.75;
                    const finalScore = Math.max(directSimilarity, indirectScore);
                    const threshold = isMultiTerm ? 25 : 30;
                    
                    if (finalScore >= threshold) {
                        symptomMatches.push({
                            name: symptom,
                            herbs: this.data.symptoms[symptom],
                            score: finalScore,
                            directScore: directSimilarity,
                            indirectScore: indirectScore,
                            matchType: directSimilarity > indirectScore ? 'direct' : 'indirect',
                            matchDetails: herbMatchDetails,
                            relevanceFactors: this.getRelevanceFactors(symptom, query, queryTerms)
                        });
                    }
                });

                // Intelligent sorting with multiple ranking factors
                const intelligentSort = (a, b) => {
                    // Primary: Weighted score considering match type
                    const scoreA = a.matchType === 'direct' ? a.score : a.score * 0.9;
                    const scoreB = b.matchType === 'direct' ? b.score : b.score * 0.9;
                    
                    if (Math.abs(scoreA - scoreB) > 5) {
                        return scoreB - scoreA;
                    }
                    
                    // Secondary: Relevance factors
                    const relevanceA = a.relevanceFactors.total;
                    const relevanceB = b.relevanceFactors.total;
                    
                    if (Math.abs(relevanceA - relevanceB) > 2) {
                        return relevanceB - relevanceA;
                    }
                    
                    // Tertiary: Name length (shorter = more specific)
                    if (Math.abs(a.name.length - b.name.length) > 2) {
                        return a.name.length - b.name.length;
                    }
                    
                    // Quaternary: Number of related items (more = more comprehensive)
                    const itemsA = a.symptoms ? a.symptoms.length : a.herbs.length;
                    const itemsB = b.symptoms ? b.symptoms.length : b.herbs.length;
                    
                    return itemsB - itemsA;
                };

                // Apply intelligent sorting and pagination
                results.herbResults = herbMatches
                    .sort(intelligentSort)
                    .slice(0, 20);

                results.symptomResults = symptomMatches
                    .sort(intelligentSort)
                    .slice(0, 20);

                // Add search analytics
                this.recordSearchAnalytics(query, results);

                return results;
            }

            // Text normalization for better matching
            normalizeText(text) {
                return text.toLowerCase()
                    .replace(/\s+/g, '') // Remove spaces
                    .replace(/[ï¼Œã€‚ã€ï¼›ï¼šï¼ï¼Ÿ]/g, '') // Remove Chinese punctuation
                    .replace(/[,.\-;:!?]/g, ''); // Remove English punctuation
            }

            // Extract keywords from query
            extractKeywords(query) {
                // Split by common separators and filter out short terms
                return query.split(/[ï¼Œã€‚ã€ï¼›ï¼š\s,.\-;:]+/)
                    .filter(term => term.length > 0)
                    .map(term => term.trim());
            }

            // Levenshtein distance similarity
            calculateLevenshteinSimilarity(str1, str2) {
                const matrix = [];
                const len1 = str1.length;
                const len2 = str2.length;

                for (let i = 0; i <= len1; i++) {
                    matrix[i] = [i];
                }

                for (let j = 0; j <= len2; j++) {
                    matrix[0][j] = j;
                }

                for (let i = 1; i <= len1; i++) {
                    for (let j = 1; j <= len2; j++) {
                        if (str1.charAt(i - 1) === str2.charAt(j - 1)) {
                            matrix[i][j] = matrix[i - 1][j - 1];
                        } else {
                            matrix[i][j] = Math.min(
                                matrix[i - 1][j - 1] + 1,
                                matrix[i][j - 1] + 1,
                                matrix[i - 1][j] + 1
                            );
                        }
                    }
                }

                const maxLen = Math.max(len1, len2);
                return maxLen === 0 ? 100 : ((maxLen - matrix[len1][len2]) / maxLen) * 100;
            }

            // Jaccard similarity for character n-grams
            calculateJaccardSimilarity(str1, str2, n = 2) {
                const getNGrams = (str, n) => {
                    const ngrams = new Set();
                    for (let i = 0; i <= str.length - n; i++) {
                        ngrams.add(str.substring(i, i + n));
                    }
                    return ngrams;
                };

                const ngrams1 = getNGrams(str1, n);
                const ngrams2 = getNGrams(str2, n);
                
                const intersection = new Set([...ngrams1].filter(x => ngrams2.has(x)));
                const union = new Set([...ngrams1, ...ngrams2]);
                
                return union.size === 0 ? 0 : (intersection.size / union.size) * 100;
            }

            // Keyword matching similarity
            calculateKeywordSimilarity(text, keywords) {
                if (keywords.length === 0) return 0;
                
                const normalizedText = this.normalizeText(text);
                let matches = 0;
                
                keywords.forEach(keyword => {
                    const normalizedKeyword = this.normalizeText(keyword);
                    if (normalizedText.includes(normalizedKeyword)) {
                        matches++;
                    }
                });
                
                return (matches / keywords.length) * 100;
            }

            // Enhanced query processing with AI-like understanding
            processSearchQuery(query) {
                const normalizedQuery = this.normalizeText(query);
                const queryTerms = this.extractKeywords(normalizedQuery);
                
                // Detect search intent
                let searchIntent = 'general';
                if (query.includes('+') || query.includes('é…') || query.includes('çµ„åˆ')) {
                    searchIntent = 'combination';
                } else if (queryTerms.length > 2) {
                    searchIntent = 'symptom_cluster';
                }
                
                // Extract synonyms and related terms
                const synonyms = this.getSynonyms(queryTerms);
                const categories = this.categorizeTerms(queryTerms);
                
                return {
                    normalizedQuery,
                    queryTerms,
                    synonyms,
                    categories,
                    isMultiTerm: queryTerms.length > 1,
                    searchIntent
                };
            }

            // TCM-specific semantic similarity
            checkSemanticSimilarity(str1, str2) {
                const semanticGroups = {
                    'è¡€è™›': ['è¡€å°‘', 'è¡€ä¸è¶³', 'è²§è¡€', 'è¡€è™›è­‰'],
                    'æ°£è™›': ['æ°£ä¸è¶³', 'æ°£å¼±', 'æ°£è™›è­‰', 'å…ƒæ°£ä¸è¶³'],
                    'é™½è™›': ['é™½æ°£ä¸è¶³', 'é™½æ°£è™›', 'é™½è™›è­‰'],
                    'é™°è™›': ['é™°æ¶²ä¸è¶³', 'é™°è™›è­‰', 'é™°è™›ç«æ—º'],
                    'æ¿•ç†±': ['æ¿•ç†±è­‰', 'æ¿•ç†±å…§è˜Š', 'æ¿•ç†±ä¸‹æ³¨'],
                    'é¢¨å¯’': ['é¢¨å¯’æ„Ÿå†’', 'é¢¨å¯’è­‰', 'å¤–æ„Ÿé¢¨å¯’'],
                    'é¢¨ç†±': ['é¢¨ç†±æ„Ÿå†’', 'é¢¨ç†±è­‰', 'å¤–æ„Ÿé¢¨ç†±'],
                    'è‚é¬±': ['è‚æ°£é¬±çµ', 'è‚é¬±æ°£æ»¯', 'è‚é¬±è­‰'],
                    'è„¾è™›': ['è„¾æ°£è™›', 'è„¾è™›è­‰', 'è„¾èƒƒè™›å¼±'],
                    'è…è™›': ['è…æ°£è™›', 'è…è™›è­‰', 'è…ç²¾ä¸è¶³']
                };
                
                for (const [key, group] of Object.entries(semanticGroups)) {
                    if ((group.includes(str1) && group.includes(str2)) ||
                        (str1 === key && group.includes(str2)) ||
                        (str2 === key && group.includes(str1))) {
                        return true;
                    }
                }
                return false;
            }

            // Get synonyms for better matching
            getSynonyms(terms) {
                const synonymMap = {
                    'é ­ç—›': ['é ­ç–¼', 'è…¦ç—›', 'åé ­ç—›'],
                    'ç™¼ç†±': ['ç™¼ç‡’', 'ç†±ç—…', 'é«”æº«å‡é«˜'],
                    'å’³å—½': ['å’³', 'ä¹¾å’³', 'å’³ç—°'],
                    'è…¹ç—›': ['è‚šå­ç—›', 'èƒƒç—›', 'è…¹éƒ¨ç–¼ç—›'],
                    'å¤±çœ ': ['ä¸çœ ', 'ç¡ä¸è‘—', 'å…¥ç¡å›°é›£'],
                    'ä¾¿ç§˜': ['å¤§ä¾¿ç§˜çµ', 'æ’ä¾¿å›°é›£', 'ä¾¿çµ'],
                    'è…¹ç€‰': ['æ‹‰è‚šå­', 'æ³„ç€‰', 'å¤§ä¾¿æºè–„'],
                    'æœˆç¶“ä¸èª¿': ['ç¶“æœŸä¸æº–', 'æœˆç¶“å¤±èª¿', 'ç¶“äº‚'],
                    'ç•¶æ­¸': ['æ­¸èº«', 'æ­¸å°¾', 'å…¨ç•¶æ­¸'],
                    'äººåƒ': ['ç´…åƒ', 'ç™½åƒ', 'é‡å±±åƒ'],
                    'ç”˜è‰': ['ç‚™ç”˜è‰', 'ç”Ÿç”˜è‰', 'èœœç‚™ç”˜è‰']
                };
                
                const synonyms = [];
                terms.forEach(term => {
                    if (synonymMap[term]) {
                        synonyms.push(...synonymMap[term]);
                    }
                });
                return synonyms;
            }

            // Categorize search terms
            categorizeTerms(terms) {
                const categories = {
                    herbs: [],
                    symptoms: [],
                    patterns: [],
                    organs: []
                };
                
                const herbKeywords = ['åƒ', 'æ­¸', 'èŠª', 'è¡“', 'è‰', 'è–‘', 'æ¡‚', 'é™„'];
                const symptomKeywords = ['ç—›', 'ç†±', 'å’³', 'ç€‰', 'è„¹', 'æ‚¶', 'æšˆ'];
                const patternKeywords = ['è™›', 'å¯¦', 'å¯’', 'ç†±', 'æ¿•', 'ç‡¥', 'é¢¨', 'ç«'];
                const organKeywords = ['å¿ƒ', 'è‚', 'è„¾', 'è‚º', 'è…', 'èƒƒ', 'è…¸'];
                
                terms.forEach(term => {
                    if (herbKeywords.some(keyword => term.includes(keyword))) {
                        categories.herbs.push(term);
                    }
                    if (symptomKeywords.some(keyword => term.includes(keyword))) {
                        categories.symptoms.push(term);
                    }
                    if (patternKeywords.some(keyword => term.includes(keyword))) {
                        categories.patterns.push(term);
                    }
                    if (organKeywords.some(keyword => term.includes(keyword))) {
                        categories.organs.push(term);
                    }
                });
                
                return categories;
            }

            // Advanced similarity algorithms
            calculateDamerauLevenshteinSimilarity(str1, str2) {
                const len1 = str1.length;
                const len2 = str2.length;
                const maxDist = len1 + len2;
                
                const H = Array(len1 + 2).fill().map(() => Array(len2 + 2).fill(0));
                H[0][0] = maxDist;
                
                for (let i = 0; i <= len1; i++) {
                    H[i + 1][0] = maxDist;
                    H[i + 1][1] = i;
                }
                
                for (let j = 0; j <= len2; j++) {
                    H[0][j + 1] = maxDist;
                    H[1][j + 1] = j;
                }
                
                const da = {};
                
                for (let i = 1; i <= len1; i++) {
                    let db = 0;
                    for (let j = 1; j <= len2; j++) {
                        const k = da[str2[j - 1]] || 0;
                        const l = db;
                        let cost = 1;
                        
                        if (str1[i - 1] === str2[j - 1]) {
                            cost = 0;
                            db = j;
                        }
                        
                        H[i + 1][j + 1] = Math.min(
                            H[i][j] + cost,
                            H[i + 1][j] + 1,
                            H[i][j + 1] + 1,
                            H[k][l] + (i - k - 1) + 1 + (j - l - 1)
                        );
                    }
                    da[str1[i - 1]] = i;
                }
                
                const maxLen = Math.max(len1, len2);
                return maxLen === 0 ? 100 : ((maxLen - H[len1 + 1][len2 + 1]) / maxLen) * 100;
            }

            calculateSoundexSimilarity(str1, str2) {
                const soundex = (str) => {
                    const code = str.toUpperCase().replace(/[^A-Z]/g, '');
                    if (!code) return '0000';
                    
                    let result = code[0];
                    const mapping = {
                        'BFPV': '1', 'CGJKQSXZ': '2', 'DT': '3',
                        'L': '4', 'MN': '5', 'R': '6'
                    };
                    
                    for (let i = 1; i < code.length && result.length < 4; i++) {
                        const char = code[i];
                        for (const [chars, digit] of Object.entries(mapping)) {
                            if (chars.includes(char) && result[result.length - 1] !== digit) {
                                result += digit;
                                break;
                            }
                        }
                    }
                    
                    return result.padEnd(4, '0');
                };
                
                const code1 = soundex(str1);
                const code2 = soundex(str2);
                
                let matches = 0;
                for (let i = 0; i < 4; i++) {
                    if (code1[i] === code2[i]) matches++;
                }
                
                return (matches / 4) * 100;
            }

            calculateMetaphoneSimilarity(str1, str2) {
                // Simplified metaphone for Chinese characters
                const metaphone = (str) => {
                    const phoneticMap = {
                        'ç•¶': 'DANG', 'æ­¸': 'GUI', 'äºº': 'REN', 'åƒ': 'SHEN',
                        'é»ƒ': 'HUANG', 'èŠª': 'QI', 'ç™½': 'BAI', 'è¡“': 'ZHU',
                        'èŒ¯': 'FU', 'è‹“': 'LING', 'ç”˜': 'GAN', 'è‰': 'CAO',
                        'å·': 'CHUAN', 'èŠ': 'XIONG', 'ç†Ÿ': 'SHU', 'åœ°': 'DI',
                        'è¡€': 'XUE', 'è™›': 'XU', 'æ°£': 'QI', 'é™°': 'YIN',
                        'é™½': 'YANG', 'æ¿•': 'SHI', 'ç†±': 'RE', 'å¯’': 'HAN'
                    };
                    
                    return str.split('').map(char => phoneticMap[char] || char).join('');
                };
                
                const meta1 = metaphone(str1);
                const meta2 = metaphone(str2);
                
                return this.calculateLevenshteinSimilarity(meta1, meta2);
            }

            // Context-aware scoring helpers
            getCategoryMatch(term, category) {
                // Check if term belongs to specified category
                const categoryPatterns = {
                    herb: ['åƒ', 'æ­¸', 'èŠª', 'è¡“', 'è‰', 'è–‘', 'æ¡‚', 'é™„', 'èŠ', 'åœ°', 'è‹“'],
                    symptom: ['ç—›', 'ç†±', 'å’³', 'ç€‰', 'è„¹', 'æ‚¶', 'æšˆ', 'è™›', 'å¯¦']
                };
                
                return categoryPatterns[category]?.some(pattern => term.includes(pattern)) || false;
            }

            hasRelatedTerms(term, relatedTerms) {
                return relatedTerms.some(related => 
                    term.includes(related) || related.includes(term)
                );
            }

            getFrequencyBonus(term) {
                // Common TCM terms get slight relevance boost
                const commonTerms = {
                    'ç•¶æ­¸': 3, 'äººåƒ': 3, 'é»ƒèŠª': 3, 'ç”˜è‰': 3,
                    'è¡€è™›': 2, 'æ°£è™›': 2, 'é™°è™›': 2, 'é™½è™›': 2,
                    'é ­ç—›': 2, 'ç™¼ç†±': 2, 'å’³å—½': 2, 'è…¹ç—›': 2
                };
                
                return commonTerms[term] || 0;
            }

            getRelevanceFactors(item, query, queryTerms) {
                const factors = {
                    exactMatch: item === query ? 10 : 0,
                    lengthSimilarity: Math.max(0, 5 - Math.abs(item.length - query.length)),
                    termOverlap: queryTerms.filter(term => item.includes(term)).length * 2,
                    total: 0
                };
                
                factors.total = factors.exactMatch + factors.lengthSimilarity + factors.termOverlap;
                return factors;
            }

            // Combination search for herb pairs
            searchCombinations(terms) {
                const combinations = [];
                // Implementation for finding herb combinations
                // This would analyze common herb pairs in the database
                return combinations;
            }

            // Symptom cluster analysis
            searchSymptomClusters(terms) {
                const clusters = [];
                // Implementation for finding related symptom patterns
                // This would group symptoms that commonly appear together
                return clusters;
            }

            // Search analytics for continuous improvement
            recordSearchAnalytics(query, results) {
                const analytics = JSON.parse(localStorage.getItem('searchAnalytics') || '{}');
                const timestamp = new Date().toISOString();
                
                if (!analytics[query]) {
                    analytics[query] = {
                        count: 0,
                        lastSearched: timestamp,
                        avgResults: 0
                    };
                }
                
                analytics[query].count++;
                analytics[query].lastSearched = timestamp;
                analytics[query].avgResults = (
                    (analytics[query].avgResults * (analytics[query].count - 1)) + 
                    (results.herbResults.length + results.symptomResults.length)
                ) / analytics[query].count;
                
                localStorage.setItem('searchAnalytics', JSON.stringify(analytics));
            }

            displaySearchResults(query, results) {
                const resultsSection = document.getElementById('resultsSection');
                const searchResults = document.getElementById('searchResults');
                
                resultsSection.classList.remove('hidden');
                searchResults.innerHTML = '';

                const totalResults = results.herbResults.length + results.symptomResults.length + 
                                  (results.combinationResults?.length || 0) + (results.relatedResults?.length || 0);

                if (totalResults === 0) {
                    searchResults.innerHTML = `
                        <div class="text-center py-8 text-gray-500">
                            <div class="text-4xl mb-4">ğŸ”</div>
                            <p class="text-lg">æœªæ‰¾åˆ°ç›¸é—œçµæœ</p>
                            <p class="text-sm mt-2">è«‹å˜—è©¦å…¶ä»–é—œéµå­—æˆ–æª¢æŸ¥æ‹¼å¯«</p>
                            <div class="mt-4 text-xs text-gray-400">
                                <p>æœå°‹å»ºè­°ï¼š</p>
                                <p>â€¢ ä½¿ç”¨ä¸­è—¥åç¨±å¦‚ã€Œç•¶æ­¸ã€ã€ã€Œäººåƒã€</p>
                                <p>â€¢ ä½¿ç”¨ç—‡ç‹€æè¿°å¦‚ã€Œé ­ç—›ã€ã€ã€Œå¤±çœ ã€</p>
                                <p>â€¢ ä½¿ç”¨è­‰å‹å¦‚ã€Œè¡€è™›ã€ã€ã€Œæ°£è™›ã€</p>
                            </div>
                        </div>
                    `;
                    return;
                }

                // Add search summary
                const summaryDiv = document.createElement('div');
                summaryDiv.className = 'mb-6 p-4 bg-gray-50 rounded-lg border';
                summaryDiv.innerHTML = `
                    <div class="flex items-center justify-between">
                        <div class="flex items-center space-x-4">
                            <span class="text-sm text-gray-600">æœå°‹ã€Œ${query}ã€æ‰¾åˆ° ${totalResults} å€‹çµæœ</span>
                            <div class="flex space-x-2 text-xs">
                                ${results.herbResults.length > 0 ? `<span class="px-2 py-1 bg-green-100 text-green-800 rounded">ä¸­è—¥ ${results.herbResults.length}</span>` : ''}
                                ${results.symptomResults.length > 0 ? `<span class="px-2 py-1 bg-blue-100 text-blue-800 rounded">ç—‡ç‹€ ${results.symptomResults.length}</span>` : ''}
                            </div>
                        </div>
                        <div class="text-xs text-gray-400">
                            æœå°‹æ™‚é–“: ${new Date().toLocaleTimeString('zh-TW')}
                        </div>
                    </div>
                `;
                searchResults.appendChild(summaryDiv);

                // Display combination results (if any)
                if (results.combinationResults && results.combinationResults.length > 0) {
                    const combinationSection = document.createElement('div');
                    combinationSection.className = 'mb-8';
                    combinationSection.innerHTML = `
                        <h4 class="font-semibold text-gray-800 mb-3 flex items-center">
                            <span class="mr-2">ğŸ”—</span>
                            <span>ä¸­è—¥çµ„åˆ</span>
                            <span class="ml-2 text-xs text-gray-500">(${results.combinationResults.length})</span>
                        </h4>
                    `;
                    searchResults.appendChild(combinationSection);
                }

                // Enhanced herb results display
                if (results.herbResults.length > 0) {
                    const herbSection = document.createElement('div');
                    herbSection.className = 'mb-8';
                    herbSection.innerHTML = `
                        <h4 class="font-semibold text-gray-800 mb-3 flex items-center">
                            <span class="mr-2">ğŸŒ¿</span>
                            <span>ä¸­è—¥</span>
                            <span class="ml-2 text-xs text-gray-500">(${results.herbResults.length})</span>
                        </h4>
                    `;

                    results.herbResults.forEach((herb, index) => {
                        const herbCard = document.createElement('div');
                        const matchBadge = this.getMatchBadge(herb.score);
                        const confidenceColor = this.getConfidenceColor(herb.score);
                        const matchTypeIcon = herb.matchType === 'direct' ? 'ğŸ¯' : 'ğŸ”—';
                        const matchTypeText = herb.matchType === 'direct' ? 'ç›´æ¥åŒ¹é…' : 'é–“æ¥åŒ¹é…';
                        
                        // Enhanced relevance indicators
                        const relevanceIndicators = [];
                        if (herb.relevanceFactors.exactMatch > 0) relevanceIndicators.push('å®Œå…¨åŒ¹é…');
                        if (herb.relevanceFactors.termOverlap > 0) relevanceIndicators.push('é—œéµè©åŒ¹é…');
                        if (herb.matchDetails && herb.matchDetails.length > 0) relevanceIndicators.push('ç—‡ç‹€ç›¸é—œ');
                        
                        herbCard.className = `bg-gradient-to-r from-green-50 to-green-25 border-l-4 border-green-500 p-4 rounded-lg mb-3 hover:shadow-md transition-shadow`;
                        herbCard.innerHTML = `
                            <div class="flex justify-between items-start mb-3">
                                <div class="flex items-center space-x-2">
                                    <h5 class="font-bold text-green-800 text-lg">${herb.name}</h5>
                                    <span class="text-xs ${confidenceColor} px-2 py-1 rounded-full">${matchBadge}</span>
                                    <span class="text-xs text-gray-500" title="${matchTypeText}">${matchTypeIcon}</span>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-medium text-gray-700">${herb.score}%</div>
                                    <div class="text-xs text-gray-500">ç›¸ä¼¼åº¦</div>
                                </div>
                            </div>
                            
                            ${relevanceIndicators.length > 0 ? `
                                <div class="mb-2 flex flex-wrap gap-1">
                                    ${relevanceIndicators.map(indicator => 
                                        `<span class="text-xs bg-green-200 text-green-800 px-2 py-1 rounded">${indicator}</span>`
                                    ).join('')}
                                </div>
                            ` : ''}
                            
                            <div class="mb-2">
                                <div class="text-xs text-gray-600 mb-1">ä¸»æ²»ç—‡ç‹€ï¼š</div>
                                <div class="flex flex-wrap gap-1">
                                    ${herb.symptoms.map(symptom => {
                                        const isHighlighted = this.isTermHighlighted(symptom, query);
                                        const matchDetail = herb.matchDetails?.find(detail => detail.symptom === symptom);
                                        const hasMatchDetail = matchDetail && matchDetail.score >= 40;
                                        
                                        return `<span class="px-2 py-1 text-xs rounded transition-colors ${
                                            isHighlighted ? 'bg-yellow-200 text-yellow-900 font-medium' : 
                                            hasMatchDetail ? 'bg-orange-100 text-orange-800' :
                                            'bg-green-100 text-green-800'
                                        } ${hasMatchDetail ? 'border border-orange-300' : ''}" 
                                        ${hasMatchDetail ? `title="åŒ¹é…åº¦: ${matchDetail.score}%"` : ''}>${symptom}</span>`;
                                    }).join('')}
                                </div>
                            </div>
                            
                            ${herb.directScore !== herb.score ? `
                                <div class="text-xs text-gray-500 mt-2 flex justify-between">
                                    <span>ç›´æ¥åŒ¹é…: ${Math.round(herb.directScore)}%</span>
                                    <span>é–“æ¥åŒ¹é…: ${Math.round(herb.indirectScore)}%</span>
                                </div>
                            ` : ''}
                        `;
                        herbSection.appendChild(herbCard);
                    });

                    searchResults.appendChild(herbSection);
                }

                // Enhanced symptom results display
                if (results.symptomResults.length > 0) {
                    const symptomSection = document.createElement('div');
                    symptomSection.className = 'mb-8';
                    symptomSection.innerHTML = `
                        <h4 class="font-semibold text-gray-800 mb-3 flex items-center">
                            <span class="mr-2">ğŸ©º</span>
                            <span>ç—‡ç‹€</span>
                            <span class="ml-2 text-xs text-gray-500">(${results.symptomResults.length})</span>
                        </h4>
                    `;

                    results.symptomResults.forEach((symptom, index) => {
                        const symptomCard = document.createElement('div');
                        const matchBadge = this.getMatchBadge(symptom.score);
                        const confidenceColor = this.getConfidenceColor(symptom.score);
                        const matchTypeIcon = symptom.matchType === 'direct' ? 'ğŸ¯' : 'ğŸ”—';
                        const matchTypeText = symptom.matchType === 'direct' ? 'ç›´æ¥åŒ¹é…' : 'é–“æ¥åŒ¹é…';
                        
                        const relevanceIndicators = [];
                        if (symptom.relevanceFactors.exactMatch > 0) relevanceIndicators.push('å®Œå…¨åŒ¹é…');
                        if (symptom.relevanceFactors.termOverlap > 0) relevanceIndicators.push('é—œéµè©åŒ¹é…');
                        if (symptom.matchDetails && symptom.matchDetails.length > 0) relevanceIndicators.push('ä¸­è—¥ç›¸é—œ');
                        
                        symptomCard.className = `bg-gradient-to-r from-blue-50 to-blue-25 border-l-4 border-blue-500 p-4 rounded-lg mb-3 hover:shadow-md transition-shadow`;
                        symptomCard.innerHTML = `
                            <div class="flex justify-between items-start mb-3">
                                <div class="flex items-center space-x-2">
                                    <h5 class="font-bold text-blue-800 text-lg">${symptom.name}</h5>
                                    <span class="text-xs ${confidenceColor} px-2 py-1 rounded-full">${matchBadge}</span>
                                    <span class="text-xs text-gray-500" title="${matchTypeText}">${matchTypeIcon}</span>
                                </div>
                                <div class="text-right">
                                    <div class="text-sm font-medium text-gray-700">${symptom.score}%</div>
                                    <div class="text-xs text-gray-500">ç›¸ä¼¼åº¦</div>
                                </div>
                            </div>
                            
                            ${relevanceIndicators.length > 0 ? `
                                <div class="mb-2 flex flex-wrap gap-1">
                                    ${relevanceIndicators.map(indicator => 
                                        `<span class="text-xs bg-blue-200 text-blue-800 px-2 py-1 rounded">${indicator}</span>`
                                    ).join('')}
                                </div>
                            ` : ''}
                            
                            <div class="mb-2">
                                <div class="text-xs text-gray-600 mb-1">ç›¸é—œä¸­è—¥ï¼š</div>
                                <div class="flex flex-wrap gap-1">
                                    ${symptom.herbs.map(herb => {
                                        const isHighlighted = this.isTermHighlighted(herb, query);
                                        const matchDetail = symptom.matchDetails?.find(detail => detail.herb === herb);
                                        const hasMatchDetail = matchDetail && matchDetail.score >= 40;
                                        
                                        return `<span class="px-2 py-1 text-xs rounded transition-colors ${
                                            isHighlighted ? 'bg-yellow-200 text-yellow-900 font-medium' : 
                                            hasMatchDetail ? 'bg-orange-100 text-orange-800' :
                                            'bg-blue-100 text-blue-800'
                                        } ${hasMatchDetail ? 'border border-orange-300' : ''}"
                                        ${hasMatchDetail ? `title="åŒ¹é…åº¦: ${matchDetail.score}%"` : ''}>${herb}</span>`;
                                    }).join('')}
                                </div>
                            </div>
                            
                            ${symptom.directScore !== symptom.score ? `
                                <div class="text-xs text-gray-500 mt-2 flex justify-between">
                                    <span>ç›´æ¥åŒ¹é…: ${Math.round(symptom.directScore)}%</span>
                                    <span>é–“æ¥åŒ¹é…: ${Math.round(symptom.indirectScore)}%</span>
                                </div>
                            ` : ''}
                        `;
                        symptomSection.appendChild(symptomCard);
                    });

                    searchResults.appendChild(symptomSection);
                }

                // Add search tips at the bottom
                const tipsDiv = document.createElement('div');
                tipsDiv.className = 'mt-8 p-4 bg-blue-50 rounded-lg border border-blue-200';
                tipsDiv.innerHTML = `
                    <div class="text-sm text-blue-800">
                        <div class="font-medium mb-2">ğŸ’¡ æœå°‹æç¤ºï¼š</div>
                        <ul class="text-xs space-y-1 text-blue-700">
                            <li>â€¢ ä½¿ç”¨ã€Œ+ã€è™Ÿæœå°‹ä¸­è—¥çµ„åˆï¼Œå¦‚ã€Œç•¶æ­¸+å·èŠã€</li>
                            <li>â€¢ è¼¸å…¥å¤šå€‹ç—‡ç‹€å¯æ‰¾åˆ°ç›¸é—œçš„è­‰å‹æ¨¡å¼</li>
                            <li>â€¢ ç³»çµ±æ”¯æ´åŒç¾©è©æœå°‹ï¼Œå¦‚ã€Œé ­ç–¼ã€æœƒåŒ¹é…ã€Œé ­ç—›ã€</li>
                            <li>â€¢ é»ƒè‰²æ¨™ç±¤è¡¨ç¤ºç›´æ¥åŒ¹é…ï¼Œæ©™è‰²è¡¨ç¤ºé«˜ç›¸é—œæ€§</li>
                        </ul>
                    </div>
                `;
                searchResults.appendChild(tipsDiv);
            }

            // Helper methods for enhanced display
            getMatchBadge(score) {
                if (score >= 95) return 'å®Œå…¨åŒ¹é…';
                if (score >= 85) return 'é«˜åº¦åŒ¹é…';
                if (score >= 70) return 'ä¸­åº¦åŒ¹é…';
                if (score >= 50) return 'ç›¸é—œåŒ¹é…';
                return 'å¼±ç›¸é—œ';
            }

            getConfidenceColor(score) {
                if (score >= 95) return 'bg-red-100 text-red-800';
                if (score >= 85) return 'bg-orange-100 text-orange-800';
                if (score >= 70) return 'bg-yellow-100 text-yellow-800';
                if (score >= 50) return 'bg-blue-100 text-blue-800';
                return 'bg-gray-100 text-gray-800';
            }

            isTermHighlighted(term, query) {
                const normalizedTerm = this.normalizeText(term);
                const normalizedQuery = this.normalizeText(query);
                return normalizedTerm.includes(normalizedQuery) || normalizedQuery.includes(normalizedTerm);
            }

            processImportData() {
                const importText = document.getElementById('importData').value.trim();
                if (!importText) {
                    this.showImportStatus('âš ï¸', 'è«‹è¼¸å…¥è¦å°å…¥çš„è³‡æ–™', 'bg-yellow-100 text-yellow-800');
                    return;
                }

                this.showImportStatus('â³', 'æ­£åœ¨è™•ç†è³‡æ–™...', 'bg-blue-100 text-blue-800');

                const lines = importText.split('\n').filter(line => line.trim());
                let successCount = 0;

                lines.forEach(line => {
                    const parts = line.split('ï¼š');
                    if (parts.length === 2) {
                        const herb = parts[0].trim();
                        const symptoms = parts[1].split(',').map(s => s.trim()).filter(s => s);
                        
                        if (herb && symptoms.length > 0) {
                            this.addHerbData(herb, symptoms);
                            successCount++;
                        }
                    }
                });

                this.saveData();
                this.updateUI();
                document.getElementById('importData').value = '';
                
                this.showImportStatus('âœ…', `æˆåŠŸå°å…¥ ${successCount} æ¢ä¸­è—¥è³‡æ–™`, 'bg-green-100 text-green-800');
                
                // Hide manual input section and status after success
                setTimeout(() => {
                    document.getElementById('manualInputSection').classList.add('hidden');
                    document.getElementById('textImportBtn').innerHTML = '<span>âœï¸</span><span>æ‰‹å‹•è¼¸å…¥</span>';
                    document.getElementById('importStatus').classList.add('hidden');
                }, 2000);
            }

            addHerbData(herb, symptoms) {
                // Add to herbs data
                if (!this.data.herbs[herb]) {
                    this.data.herbs[herb] = [];
                }
                
                symptoms.forEach(symptom => {
                    if (!this.data.herbs[herb].includes(symptom)) {
                        this.data.herbs[herb].push(symptom);
                    }
                    
                    // Add to symptoms data
                    if (!this.data.symptoms[symptom]) {
                        this.data.symptoms[symptom] = [];
                    }
                    if (!this.data.symptoms[symptom].includes(herb)) {
                        this.data.symptoms[symptom].push(herb);
                    }
                });
            }

            toggleManualInput() {
                const manualSection = document.getElementById('manualInputSection');
                const isHidden = manualSection.classList.contains('hidden');
                
                if (isHidden) {
                    manualSection.classList.remove('hidden');
                    document.getElementById('textImportBtn').textContent = 'âœï¸ éš±è—è¼¸å…¥';
                } else {
                    manualSection.classList.add('hidden');
                    document.getElementById('textImportBtn').innerHTML = '<span>âœï¸</span><span>æ‰‹å‹•è¼¸å…¥</span>';
                }
            }

            triggerFileImport() {
                document.getElementById('fileInput').click();
            }

            handleFileImport(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.showImportStatus('â³', 'æ­£åœ¨è™•ç†æª”æ¡ˆ...', 'bg-blue-100 text-blue-800');

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const content = e.target.result;
                        let successCount = 0;
                        
                        if (file.name.endsWith('.json')) {
                            const importedData = JSON.parse(content);
                            // Handle both direct data and metadata wrapped data
                            if (importedData.data) {
                                this.data = importedData.data;
                                successCount = Object.keys(importedData.data.herbs || {}).length;
                            } else {
                                this.data = importedData;
                                successCount = Object.keys(importedData.herbs || {}).length;
                            }
                        } else {
                            // Process text file
                            const lines = content.split('\n').filter(line => line.trim());
                            lines.forEach(line => {
                                const parts = line.split('ï¼š');
                                if (parts.length === 2) {
                                    const herb = parts[0].trim();
                                    const symptoms = parts[1].split(',').map(s => s.trim()).filter(s => s);
                                    
                                    if (herb && symptoms.length > 0) {
                                        this.addHerbData(herb, symptoms);
                                        successCount++;
                                    }
                                }
                            });
                        }
                        
                        this.saveData();
                        this.updateUI();
                        this.showImportStatus('âœ…', `æˆåŠŸå°å…¥ ${successCount} æ¢è³‡æ–™`, 'bg-green-100 text-green-800');
                        
                        // Hide status after 3 seconds
                        setTimeout(() => {
                            document.getElementById('importStatus').classList.add('hidden');
                        }, 3000);
                        
                    } catch (error) {
                        this.showImportStatus('âŒ', 'æª”æ¡ˆæ ¼å¼éŒ¯èª¤ï¼Œè«‹æª¢æŸ¥æª”æ¡ˆå…§å®¹', 'bg-red-100 text-red-800');
                    }
                };
                reader.readAsText(file);
                
                // Reset file input
                event.target.value = '';
            }

            showImportStatus(icon, text, className) {
                const statusDiv = document.getElementById('importStatus');
                const statusIcon = document.getElementById('statusIcon');
                const statusText = document.getElementById('statusText');
                
                statusIcon.textContent = icon;
                statusText.textContent = text;
                statusDiv.className = `p-3 rounded-lg ${className}`;
                statusDiv.classList.remove('hidden');
            }

            // New Backup System
            showBackupModal() {
                const herbCount = Object.keys(this.data.herbs).length;
                const symptomCount = Object.keys(this.data.symptoms).length;
                const lastUpdate = localStorage.getItem('tcmLastUpdate') || 'å¾æœªæ›´æ–°';
                
                document.getElementById('backupHerbCount').textContent = herbCount;
                document.getElementById('backupSymptomCount').textContent = symptomCount;
                document.getElementById('lastUpdateTime').textContent = lastUpdate;
                
                document.getElementById('backupModal').classList.remove('hidden');
                document.getElementById('backupModal').classList.add('flex');
            }

            hideBackupModal() {
                document.getElementById('backupModal').classList.add('hidden');
                document.getElementById('backupModal').classList.remove('flex');
                // Hide status message
                document.getElementById('backupStatus').classList.add('hidden');
            }

            downloadBackup() {
                try {
                    const backupData = this.createBackupData();
                    const timestamp = new Date().toISOString().slice(0, 19).replace(/[:.]/g, '-');
                    const filename = `TCM_Backup_${timestamp}.json`;
                    
                    const blob = new Blob([JSON.stringify(backupData, null, 2)], { 
                        type: 'application/json' 
                    });
                    
                    const url = URL.createObjectURL(blob);
                    const link = document.createElement('a');
                    link.href = url;
                    link.download = filename;
                    link.click();
                    
                    URL.revokeObjectURL(url);
                    
                    this.showBackupStatus('âœ…', 'å‚™ä»½æª”æ¡ˆå·²ä¸‹è¼‰å®Œæˆï¼', 'bg-green-100 text-green-800');
                } catch (error) {
                    this.showBackupStatus('âŒ', 'ä¸‹è¼‰å¤±æ•—ï¼Œè«‹é‡è©¦', 'bg-red-100 text-red-800');
                }
            }

            async copyBackupToClipboard() {
                try {
                    const backupData = this.createBackupData();
                    const backupText = JSON.stringify(backupData, null, 2);
                    
                    await navigator.clipboard.writeText(backupText);
                    this.showBackupStatus('âœ…', 'å‚™ä»½è³‡æ–™å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', 'bg-green-100 text-green-800');
                } catch (error) {
                    // Fallback for older browsers
                    const textArea = document.createElement('textarea');
                    textArea.value = JSON.stringify(this.createBackupData(), null, 2);
                    document.body.appendChild(textArea);
                    textArea.select();
                    document.execCommand('copy');
                    document.body.removeChild(textArea);
                    
                    this.showBackupStatus('âœ…', 'å‚™ä»½è³‡æ–™å·²è¤‡è£½åˆ°å‰ªè²¼ç°¿ï¼', 'bg-green-100 text-green-800');
                }
            }

            triggerBackupRestore() {
                document.getElementById('backupFileInput').click();
            }

            handleBackupRestore(event) {
                const file = event.target.files[0];
                if (!file) return;

                this.showBackupStatus('â³', 'æ­£åœ¨æ¢å¾©å‚™ä»½...', 'bg-blue-100 text-blue-800');

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const backupData = JSON.parse(e.target.result);
                        
                        if (this.validateBackupData(backupData)) {
                            // Confirm before restore
                            if (confirm('ç¢ºå®šè¦æ¢å¾©æ­¤å‚™ä»½å—ï¼Ÿé€™å°‡è¦†è“‹ç¾æœ‰çš„æ‰€æœ‰è³‡æ–™ã€‚')) {
                                this.restoreFromBackup(backupData);
                                this.showBackupStatus('âœ…', 'å‚™ä»½æ¢å¾©æˆåŠŸï¼', 'bg-green-100 text-green-800');
                                
                                // Update UI and close modal after delay
                                setTimeout(() => {
                                    this.hideBackupModal();
                                    this.updateUI();
                                }, 1500);
                            } else {
                                this.showBackupStatus('â„¹ï¸', 'æ¢å¾©å·²å–æ¶ˆ', 'bg-gray-100 text-gray-800');
                            }
                        } else {
                            this.showBackupStatus('âŒ', 'å‚™ä»½æª”æ¡ˆæ ¼å¼ä¸æ­£ç¢º', 'bg-red-100 text-red-800');
                        }
                    } catch (error) {
                        this.showBackupStatus('âŒ', 'å‚™ä»½æª”æ¡ˆæå£æˆ–æ ¼å¼éŒ¯èª¤', 'bg-red-100 text-red-800');
                    }
                };
                
                reader.readAsText(file);
                event.target.value = ''; // Reset file input
            }

            createBackupData() {
                return {
                    version: '2.0',
                    appName: 'ä¸­é†«è¨ºç—‡è¼”åŠ©å·¥å…·',
                    backupDate: new Date().toISOString(),
                    backupTime: new Date().toLocaleString('zh-TW'),
                    statistics: {
                        herbCount: Object.keys(this.data.herbs).length,
                        symptomCount: Object.keys(this.data.symptoms).length,
                        totalRelations: Object.values(this.data.herbs).reduce((sum, symptoms) => sum + symptoms.length, 0)
                    },
                    data: {
                        herbs: this.data.herbs,
                        symptoms: this.data.symptoms
                    },
                    checksum: this.generateChecksum(this.data)
                };
            }

            validateBackupData(backupData) {
                // Check required fields
                if (!backupData.data || !backupData.data.herbs || !backupData.data.symptoms) {
                    return false;
                }
                
                // Check data structure
                if (typeof backupData.data.herbs !== 'object' || typeof backupData.data.symptoms !== 'object') {
                    return false;
                }
                
                // Validate checksum if present
                if (backupData.checksum) {
                    const calculatedChecksum = this.generateChecksum(backupData.data);
                    if (calculatedChecksum !== backupData.checksum) {
                        console.warn('Backup checksum mismatch - data may be corrupted');
                    }
                }
                
                return true;
            }

            restoreFromBackup(backupData) {
                this.data = {
                    herbs: backupData.data.herbs,
                    symptoms: backupData.data.symptoms
                };
                
                this.saveData();
                this.updateLastUpdateTime();
                
                // Clear search results
                document.getElementById('resultsSection').classList.add('hidden');
                document.getElementById('searchInput').value = '';
            }

            generateChecksum(data) {
                // Simple checksum generation
                const str = JSON.stringify(data);
                let hash = 0;
                for (let i = 0; i < str.length; i++) {
                    const char = str.charCodeAt(i);
                    hash = ((hash << 5) - hash) + char;
                    hash = hash & hash; // Convert to 32-bit integer
                }
                return hash.toString(16);
            }

            showBackupStatus(icon, text, className) {
                const statusDiv = document.getElementById('backupStatus');
                const statusIcon = document.getElementById('backupStatusIcon');
                const statusText = document.getElementById('backupStatusText');
                
                statusIcon.textContent = icon;
                statusText.textContent = text;
                statusDiv.className = `mt-4 p-3 rounded-lg text-sm ${className}`;
                statusDiv.classList.remove('hidden');
                
                // Auto hide success messages
                if (icon === 'âœ…') {
                    setTimeout(() => {
                        statusDiv.classList.add('hidden');
                    }, 3000);
                }
            }



            updateUI() {
                const herbCount = Object.keys(this.data.herbs).length;
                const symptomCount = Object.keys(this.data.symptoms).length;
                
                document.getElementById('herbCount').textContent = herbCount;
                document.getElementById('symptomCount').textContent = symptomCount;
            }



            saveData() {
                localStorage.setItem('tcmData', JSON.stringify(this.data));
                this.updateLastUpdateTime();
            }

            updateLastUpdateTime() {
                const now = new Date().toLocaleString('zh-TW');
                localStorage.setItem('tcmLastUpdate', now);
            }

            // Show real-time search suggestions
            showSearchSuggestions(query) {
                const suggestionsDiv = document.getElementById('searchSuggestions');
                
                if (!query || query.length < 1) {
                    this.hideSearchSuggestions();
                    return;
                }

                const suggestions = this.generateSuggestions(query);
                
                if (suggestions.length === 0) {
                    this.hideSearchSuggestions();
                    return;
                }

                suggestionsDiv.innerHTML = '';
                suggestions.forEach(suggestion => {
                    const suggestionItem = document.createElement('div');
                    suggestionItem.className = 'px-4 py-3 hover:bg-gray-50 cursor-pointer border-b border-gray-100 last:border-b-0 flex items-center justify-between';
                    suggestionItem.innerHTML = `
                        <div class="flex items-center space-x-3">
                            <span class="text-lg">${suggestion.icon}</span>
                            <div>
                                <div class="font-medium text-gray-800">${this.highlightMatch(suggestion.text, query)}</div>
                                <div class="text-xs text-gray-500">${suggestion.type} â€¢ ${suggestion.count} å€‹ç›¸é—œé …ç›®</div>
                            </div>
                        </div>
                        <div class="text-xs text-gray-400">${suggestion.score}%</div>
                    `;
                    
                    suggestionItem.addEventListener('click', () => {
                        document.getElementById('searchInput').value = suggestion.text;
                        this.hideSearchSuggestions();
                        this.search();
                    });
                    
                    suggestionsDiv.appendChild(suggestionItem);
                });

                suggestionsDiv.classList.remove('hidden');
            }

            // Generate search suggestions
            generateSuggestions(query) {
                const suggestions = [];
                const normalizedQuery = this.normalizeText(query);

                // Get suggestions from herbs
                Object.keys(this.data.herbs).forEach(herb => {
                    const similarity = this.calculateAdvancedSimilarity(herb, query);
                    if (similarity >= 40) {
                        suggestions.push({
                            text: herb,
                            type: 'ä¸­è—¥',
                            icon: 'ğŸŒ¿',
                            score: Math.round(similarity),
                            count: this.data.herbs[herb].length,
                            category: 'herb'
                        });
                    }
                });

                // Get suggestions from symptoms
                Object.keys(this.data.symptoms).forEach(symptom => {
                    const similarity = this.calculateAdvancedSimilarity(symptom, query);
                    if (similarity >= 40) {
                        suggestions.push({
                            text: symptom,
                            type: 'ç—‡ç‹€',
                            icon: 'ğŸ©º',
                            score: Math.round(similarity),
                            count: this.data.symptoms[symptom].length,
                            category: 'symptom'
                        });
                    }
                });

                // Sort by similarity score and limit results
                return suggestions
                    .sort((a, b) => b.score - a.score)
                    .slice(0, 8);
            }

            // Highlight matching parts in suggestions
            highlightMatch(text, query) {
                const normalizedText = this.normalizeText(text);
                const normalizedQuery = this.normalizeText(query);
                
                if (normalizedText.includes(normalizedQuery)) {
                    const index = normalizedText.indexOf(normalizedQuery);
                    const before = text.substring(0, index);
                    const match = text.substring(index, index + query.length);
                    const after = text.substring(index + query.length);
                    return `${before}<mark class="bg-yellow-200 px-1 rounded">${match}</mark>${after}`;
                }
                
                return text;
            }

            // Hide search suggestions
            hideSearchSuggestions() {
                document.getElementById('searchSuggestions').classList.add('hidden');
            }

            // Calculate advanced similarity (reused from search)
            calculateAdvancedSimilarity(str1, str2) {
                const norm1 = this.normalizeText(str1);
                const norm2 = this.normalizeText(str2);
                
                if (norm1 === norm2) return 100;
                if (norm1.includes(norm2) || norm2.includes(norm1)) return 95;
                if (norm1.startsWith(norm2) || norm2.startsWith(norm1)) return 90;
                if (norm1.endsWith(norm2) || norm2.endsWith(norm1)) return 85;
                
                const levenshteinScore = this.calculateLevenshteinSimilarity(norm1, norm2);
                const jaccardScore = this.calculateJaccardSimilarity(norm1, norm2);
                
                return Math.max(levenshteinScore * 0.6, jaccardScore * 0.4);
            }
        }

        // Initialize the application
        document.addEventListener('DOMContentLoaded', () => {
            new TCMDiagnosticTool();
        });
    </script>
<script>(function(){function c(){var b=a.contentDocument||a.contentWindow.document;if(b){var d=b.createElement('script');d.innerHTML="window.__CF$cv$params={r:'965208a5031a09b8',t:'MTc1MzUxMzM3MC4wMDAwMDA='};var a=document.createElement('script');a.nonce='';a.src='/cdn-cgi/challenge-platform/scripts/jsd/main.js';document.getElementsByTagName('head')[0].appendChild(a);";b.getElementsByTagName('head')[0].appendChild(d)}}if(document.body){var a=document.createElement('iframe');a.height=1;a.width=1;a.style.position='absolute';a.style.top=0;a.style.left=0;a.style.border='none';a.style.visibility='hidden';document.body.appendChild(a);if('loading'!==document.readyState)c();else if(window.addEventListener)document.addEventListener('DOMContentLoaded',c);else{var e=document.onreadystatechange||function(){};document.onreadystatechange=function(b){e(b);'loading'!==document.readyState&&(document.onreadystatechange=e,c())}}}})();</script></body>
</html>
